# üìò PROTOCOLO DE CALIDAD DE C√ìDIGO - DamianApp v2.1

## üéØ **Prop√≥sito**
Protocolo **auto-validable y confiable** que garantiza que una IA pueda detectar, rechazar y corregir problemas cr√≠ticos autom√°ticamente, asegurando c√≥digo Expert Level sin omisiones.

## üåü **Filosof√≠a Central: "TRUST-FIRST QUALITY"**
> *"Un protocolo que la IA no puede confiar es un protocolo que falla. Primero correcci√≥n, despu√©s optimizaci√≥n."*

## üö® **0. PRE-AUDITOR√çA OBLIGATORIA (CR√çTICA)**

### **‚õî ANTES DE CUALQUIER OTRA ACCI√ìN, LA IA DEBE:**

#### **üîç PASO 1: DETECCI√ìN AUTOM√ÅTICA DE ERRORES CR√çTICOS**
```javascript
// ü§ñ ALGORITMO OBLIGATORIO para la IA:
const preAuditoriaObligatoria = async (codigoBase) => {
  const erroresCriticos = [];
  
  // üìö DUPLICACI√ìN: Detectar archivos/funciones id√©nticos
  const duplicados = await detectarDuplicacion(codigoBase);
  if (duplicados.length > 0) {
    erroresCriticos.push({
      tipo: 'DUPLICACION_CRITICA',
      prioridad: 1, // M√ÅXIMA
      archivos: duplicados,
      accion: 'DETENER_TODO_Y_CONSOLIDAR_PRIMERO'
    });
  }
  
  // üîê SEGURIDAD: Vulnerabilidades detectables
  const vulnerabilidades = await escanearSeguridad(codigoBase);
  if (vulnerabilidades.length > 0) {
    erroresCriticos.push({
      tipo: 'VULNERABILIDAD_SEGURIDAD',
      prioridad: 2,
      detalles: vulnerabilidades,
      accion: 'RECHAZAR_HASTA_CORRECION'
    });
  }
  
  // üí• ERRORES FATALES: Syntax, imports rotos, etc.
  const erroresFatales = await validarSintaxis(codigoBase);
  if (erroresFatales.length > 0) {
    erroresCriticos.push({
      tipo: 'ERROR_FATAL',
      prioridad: 3,
      errores: erroresFatales,
      accion: 'CORREGIR_INMEDIATAMENTE'
    });
  }
  
  return erroresCriticos;
};
```

#### **üìã PASO 2: ORDEN DE PRIORIDADES INFLEXIBLE**
```javascript
// ü§ñ LA IA DEBE SEGUIR ESTE ORDEN SIN EXCEPCIONES:
const ordenPrioridadesIA = [
  // üö® PRIORIDAD 1: DUPLICACI√ìN (Viola DRY, aumenta debt)
  {
    orden: 1,
    accion: 'eliminar_duplicados',
    criterio: 'codigo_identico > 80% similaridad',
    bloqueante: true, // No continuar hasta resolver
    mensaje: 'DETECTADA DUPLICACI√ìN CR√çTICA - CONSOLIDANDO ANTES DE CONTINUAR'
  },
  
  // üîê PRIORIDAD 2: SEGURIDAD (Riesgo inmediato)
  {
    orden: 2,
    accion: 'corregir_vulnerabilidades',
    criterio: 'vulnerabilidades_detectadas > 0',
    bloqueante: true,
    mensaje: 'VULNERABILIDADES DETECTADAS - CORRIGIENDO ANTES DE CONTINUAR'
  },
  
  // üí• PRIORIDAD 3: ERRORES FATALES (App rota)
  {
    orden: 3,
    accion: 'corregir_errores_sintaxis',
    criterio: 'errores_compilacion > 0',
    bloqueante: true,
    mensaje: 'ERRORES DE COMPILACI√ìN - CORRIGIENDO ANTES DE CONTINUAR'
  },
  
  // üìä PRIORIDAD 4: APLICAR PROTOCOLO seg√∫n contexto
  {
    orden: 4,
    accion: 'aplicar_protocolo_calidad',
    criterio: 'errores_criticos === 0',
    bloqueante: false,
    mensaje: 'APLICANDO MEJORAS DE CALIDAD SEG√öN CONTEXTO'
  }
];
```

#### **‚úÖ PASO 3: CHECKLIST AUTO-VALIDACI√ìN IA**
```javascript
// ü§ñ LA IA DEBE VALIDARSE A S√ç MISMA ANTES DE PROPONER CAMBIOS:
const checklistAutoValidacionIA = {
  
  // ‚úÖ Pre-requisitos cumplidos
  preRequisitos: [
    '¬øEjecut√© pre-auditor√≠a completa?',
    '¬øDetect√© TODOS los duplicados?',
    '¬øVerifiqu√© seguridad exhaustivamente?',
    '¬øValid√© que el c√≥digo compile?'
  ],
  
  // ‚úÖ An√°lisis de impacto
  analisisImpacto: [
    '¬øIdentifiqu√© correctamente el contexto (CRITICAL/CORE/FEATURE/EXPERIMENT)?',
    '¬øApliqu√© el nivel de rigor apropiado?',
    '¬øDocument√© todas las excepciones?',
    '¬øVerifiqu√© que mis cambios no rompan nada?'
  ],
  
  // ‚úÖ Calidad de propuesta
  calidadPropuesta: [
    '¬øMis cambios siguen SOLID seg√∫n contexto?',
    '¬øLa nomenclatura es clara y educativa?',
    '¬øAgregu√© comentarios did√°cticos donde necesario?',
    '¬øLos tests cubren los cambios cr√≠ticos?'
  ],
  
  // ‚úÖ Verificaci√≥n final
  verificacionFinal: [
    '¬øPuedo explicar CADA cambio propuesto?',
    '¬øLos cambios mejoran realmente la calidad?',
    '¬øNo introduje nueva duplicaci√≥n o deuda t√©cnica?',
    '¬øEl c√≥digo resultante es mantenible a largo plazo?'
  ]
};

// üö´ SI CUALQUIER RESPUESTA ES "NO" ‚Üí REVISAR ANTES DE PROPONER
```

### **üîß ALGORITMOS DE DETECCI√ìN AUTOM√ÅTICA**

#### **üìä Detecci√≥n de Duplicaci√≥n Autom√°tica**
```javascript
// ü§ñ Algoritmo que la IA debe usar para detectar duplicados:
const detectarDuplicacionAutomatica = (archivos) => {
  const duplicados = [];
  
  // üìÅ ARCHIVOS ID√âNTICOS: Mismo nombre en diferentes ubicaciones
  const nombresArchivos = new Map();
  archivos.forEach(archivo => {
    const nombre = path.basename(archivo);
    if (nombresArchivos.has(nombre)) {
      duplicados.push({
        tipo: 'ARCHIVO_DUPLICADO',
        original: nombresArchivos.get(nombre),
        duplicado: archivo,
        similaridad: 100,
        accion: 'CONSOLIDAR_EN_UNA_UBICACION'
      });
    } else {
      nombresArchivos.set(nombre, archivo);
    }
  });
  
  // üîç C√ìDIGO SIMILAR: AST comparison
  archivos.forEach((archivo1, i) => {
    archivos.slice(i + 1).forEach(archivo2 => {
      const similaridad = calcularSimilitudCodigo(archivo1, archivo2);
      if (similaridad > 80) {
        duplicados.push({
          tipo: 'CODIGO_DUPLICADO',
          archivo1,
          archivo2,
          similaridad,
          accion: 'EXTRAER_A_FUNCION_COMUN'
        });
      }
    });
  });
  
  return duplicados;
};

// üéØ EJEMPLO DETECCI√ìN EN DAMIANAPP:
// ‚ùå DETECTADO: hapticsService.js en m√∫ltiples ubicaciones
// ‚ùå DETECTADO: utilsService.js duplicado
// ‚ùå DETECTADO: dinamicImportService.js en 2 sitios
// üö® ACCI√ìN OBLIGATORIA: Consolidar antes de cualquier mejora
```

#### **üõ°Ô∏è Detecci√≥n de Problemas de Arquitectura**
```javascript
// ü§ñ Detectar violaciones arquitect√≥nicas autom√°ticamente:
const detectarProblemasArquitectura = (codigoBase) => {
  const problemas = [];
  
  // üèóÔ∏è RESPONSABILIDAD √öNICA: Detectar clases/funciones que hacen mucho
  codigoBase.clases.forEach(clase => {
    const responsabilidades = analizarResponsabilidades(clase);
    if (responsabilidades.length > 1) {
      problemas.push({
        tipo: 'VIOLACION_SRP',
        archivo: clase.archivo,
        responsabilidades,
        sugerencia: 'DIVIDIR_EN_CLASES_ESPECIFICAS'
      });
    }
  });
  
  // üîÑ DEPENDENCIAS CIRCULARES: Graph analysis
  const dependenciasCirculares = detectarDependenciasCirculares(codigoBase);
  if (dependenciasCirculares.length > 0) {
    problemas.push({
      tipo: 'DEPENDENCIA_CIRCULAR',
      ciclos: dependenciasCirculares,
      accion: 'REFACTORIZAR_DEPENDENCIAS'
    });
  }
  
  return problemas;
};
```

---

## ÔøΩ **1. MATRIZ DE CONTEXTOS (Context-Aware Quality)**

### **üéØ Diferentes tipos de c√≥digo requieren diferentes niveles de rigor**

| **Contexto** | **Rigor** | **Cobertura** | **Velocidad** | **Aplicaci√≥n en DamianApp** |
|--------------|-----------|---------------|----### **üèóÔ∏è CORE Code Checklist (90% obligatorio):**
- [ ] ‚úÖ Principios SOLID mayormente aplicados
- [ ] üßπ Nomenclatura clara (h√≠brido inteligente espa√±ol-ingl√©s)
- [ ] üìè Funciones < 30 l√≠neas bien estructuradas con comentarios did√°cticos
- [ ] üß™ 85%+ test coverage significativo
- [ ] üö® Error handling en flujos principales con mensajes educativos
- [ ] üìù Comentarios estrat√©gicos con tono did√°ctico cuando necesario
- [ ] üë• Code review por 1+ desarrollador que valide comprensi√≥n---|----------------------------|
| **üö® CRITICAL** | 100% protocolo | 100% tests | Sin prisa | Auth, Data persistence, TEA safety |
| **ÔøΩüèóÔ∏è CORE** | 90% protocolo | 85% tests | Moderada | Services, APIs, Business logic |
| **üé® FEATURE** | 70% protocolo | 70% tests | √Ågil | UI Components, Screens |
| **‚ö° EXPERIMENT** | 40% protocolo | 30% tests | R√°pida | Prototypes, POCs, Spikes |

### **üìã Context Detection Rules:**
```javascript
// üö® CRITICAL: M√°ximo rigor (src/services/core/)
const processUserData = async (userData) => {
  // OBLIGATORIO: validaci√≥n completa, tests 100%, error handling robusto
  if (!validateUserInput(userData)) throw new ValidationError('Invalid user data');
  // ... c√≥digo ultra-robusto
};

// üé® FEATURE: Rigor moderado (src/components/)
const TimerButton = ({ onPress, disabled }) => {
  // Permitido: l√≥gica simple, tests de comportamiento, menos validaci√≥n
  return <Button onPress={onPress} disabled={disabled} />;
};

// ‚ö° EXPERIMENT: M√≠nimo viable (src/experiments/)
const testNewAlgorithm = (data) => {
  // Temporal: console.log OK, funciones largas aceptables, sin tests inicialmente
  console.log('Testing new approach...'); // Permitido en experimentos
  // ... experimentaci√≥n r√°pida
};
```

### **üéØ DamianApp Context Mapping:**
```javascript
const contextMapping = {
  CRITICAL: [
    'src/services/core/storage/',    // Persistencia de datos cr√≠ticos
    'src/services/core/config/',     // Configuraci√≥n de app
    'src/services/media/audio/',     // Sonidos terap√©uticos TEA
    'src/context/AppContext.js'      // Estado global cr√≠tico
  ],
  
  CORE: [
    'src/services/business/',        // L√≥gica de negocio
    'src/services/media/haptics/',   // Feedback t√°ctil
    'src/hooks/',                    // React integration layer
    'src/navigation/'                // Navegaci√≥n de app
  ],
  
  FEATURE: [
    'src/components/',               // Componentes UI
    'src/screens/',                  // Pantallas de usuario
    'src/theme/'                     // Sistema de dise√±o
  ],
  
  EXPERIMENT: [
    'src/experiments/',              // Features experimentales
    'temp_old_services/',            // C√≥digo de migraci√≥n
    'prototypes/'                    // Prototipos y pruebas
  ]
};
```

---

## üß† **2. PRINCIPIOS FUNDAMENTALES (Cognitive Load Optimized)**

### **üéØ 3-2-1 Rule: Informaci√≥n procesable**
- **3 principios** fundamentales (en lugar de 38 reglas)
- **2 m√©tricas** principales por contexto  
- **1 pregunta** clave: ¬øA√±ade valor al usuario?

### **üî• Los 3 Principios Fundamentales:**

#### **1. üéØ CLARITY OVER CLEVERNESS**
```javascript
// ‚ùå Clever pero confuso
const u = users.filter(u => u.r === 'a' && u.s).map(u => ({...u, p: u.p * 1.1}));

// ‚úÖ Claro y mantenible
const activeAdmins = users
  .filter(user => user.role === 'admin' && user.isActive)
  .map(user => ({ ...user, priority: user.priority * 1.1 }));

// ‚úÖ Espa√±ol para dominio TEA espec√≠fico
const configuracionesTerapia = getTerapiaConfig();
const esUsuarioTerapeuta = checkUserRole('terapeuta');
```

#### **2. üõ°Ô∏è FAIL FAST & SAFE (Fallar R√°pido y Seguro)**
```javascript
// ‚úÖ Falla r√°pido con informaci√≥n √∫til y educativa
const validarConfiguracionAudio = (configuracion) => {
  // üìö VALIDACI√ìN: Verificamos cada requisito paso a paso para 
  // que sea f√°cil encontrar exactamente qu√© est√° mal
  
  if (!configuracion) {
    throw new ErrorConfigAudio(
      'Se requiere configuraci√≥n de audio', 
      { recibido: configuracion, ayuda: 'Debe ser un objeto con propiedades volume, enabled, etc.' }
    );
  }
  
  if (!configuracion.volume) {
    throw new ErrorConfigAudio(
      'Falta la propiedad volume en configuraci√≥n', 
      { configuracion, ayuda: 'volume debe ser un n√∫mero entre 0 y 1' }
    );
  }
  
  if (configuracion.volume < 0 || configuracion.volume > 1) {
    throw new ErrorConfigAudio(
      'Volume fuera del rango permitido', 
      { 
        volumenRecibido: configuracion.volume, 
        rangoPermitido: [0, 1],
        ayuda: '0 = silencio, 1 = volumen m√°ximo'
      }
    );
  }
  
  // üìö Si llegamos aqu√≠, todo est√° bien y podemos continuar seguro
  return true;
};
```

#### **3. üîÑ OPTIMIZE FOR CHANGE (Optimizar para el Cambio)**
```javascript
// ‚úÖ F√°cil de extender sin modificar c√≥digo existente
// üìö PATR√ìN STRATEGY: Usamos un objeto para mapear tipos de audio a funciones
// Esto permite agregar nuevos sonidos sin tocar el c√≥digo principal
const manejadoresDeAudio = {
  'cambio-frase': () => reproducirSonidoCambioFrase(),
  'celebracion': () => reproducirCelebracionEpica(),
  'casi-terminado': () => reproducirSonidoCasiTerminado(),
  'motivacion': () => reproducirSonidoMotivacion(),
  // üìö EXTENSIBILIDAD: Para agregar un nuevo tipo, solo agregamos aqu√≠:
  // 'nuevo-tipo': () => reproducirNuevoSonido(),
};

const reproducirAudioPorTipo = (tipo) => {
  // üìö FALLBACK: Si no existe el tipo, usamos sonido por defecto
  // Esto evita errores y mantiene la app funcionando
  const manejador = manejadoresDeAudio[tipo] || manejadoresDeAudio['default'];
  
  if (!manejador) {
    console.warn(`Tipo de audio no encontrado: ${tipo}. Usando silencio.`);
    return;
  }
  
  return manejador();
};

// üìö BENEFICIO: Para agregar m√∫sica relajante, solo hacemos:
// manejadoresDeAudio['musica-relajante'] = () => reproducirMusicaRelajante();
// ¬°Sin tocar nada m√°s del c√≥digo!
```

---

## üèóÔ∏è **3. PRINCIPIOS SOLID (Contextualizados)**

### **Aplicaci√≥n seg√∫n contexto:**
- **üö® CRITICAL**: 100% cumplimiento SOLID obligatorio
- **üèóÔ∏è CORE**: 90% cumplimiento, excepciones documentadas
- **üé® FEATURE**: 70% cumplimiento, flexibilidad en UI
- **‚ö° EXPERIMENT**: 40% cumplimiento, enfoque en aprendizaje r√°pido
### **S - Single Responsibility Principle**
```javascript
// ‚ùå Clase con m√∫ltiples responsabilidades (CR√çTICO: siempre rechazar)
class ConfigService {
  saveConfig() { /* persistencia */ }
  validateConfig() { /* validaci√≥n */ }
  sendAnalytics() { /* analytics */ }
  renderUI() { /* UI */ }
}

// ‚úÖ Responsabilidad √∫nica (CORE y CRITICAL: obligatorio)
class ConfigService {
  saveConfig() { /* solo persistencia */ }
}
class ConfigValidator {
  validateConfig() { /* solo validaci√≥n */ }
}

// ‚ö° EXPERIMENT: Permitido temporalmente con documentaci√≥n
class QuickPrototype {
  // TODO: Refactor to separate responsibilities before moving to CORE
  validateAndSave() { /* prototipado r√°pido - temporal */ }
}
```

### **O - Open/Closed Principle**
```javascript
// ‚úÖ Extensible sin modificar c√≥digo existente
class ThemeProvider {
  getTheme(themeName) {
    return THEME_REGISTRY[themeName] || DEFAULT_THEME;
  }
}
// Agregar nuevos temas sin tocar ThemeProvider
```

### **L - Liskov Substitution Principle**
```javascript
// ‚úÖ Subclases respetan contrato del padre
class StorageService {
  async save(key, value) { /* contrato */ }
}

class AsyncStorageService extends StorageService {
  async save(key, value) { /* misma interfaz */ }
}
```

### **I - Interface Segregation Principle**
```javascript
// ‚ùå Interfaz monol√≠tica
interface MegaService {
  audio(), haptics(), storage(), validation(), ui()
}

// ‚úÖ Interfaces espec√≠ficas
interface AudioService { playSound(), setVolume() }
interface HapticsService { vibrate(), pulse() }
```

### **D - Dependency Inversion Principle**
```javascript
// ‚úÖ Depender de abstracciones
class ConfigService {
  constructor(storage) { // Abstracci√≥n inyectada
    this.storage = storage;
  }
}
```

---

## üìä **4. M√âTRICAS INTELIGENTES (Quality, not Theater)**

### **üéØ M√©tricas por contexto que realmente importan:**

#### **üö® CRITICAL Code Metrics:**
| **M√©trica** | **Target** | **Raz√≥n** |
|-------------|------------|-----------|
| **Mutation Testing** | 95%+ | Tests que realmente detectan bugs |
| **Cyclomatic Complexity** | < 5 | C√≥digo simple y predecible |
| **Error Recovery Paths** | 100% tested | Fallos seguros en c√≥digo cr√≠tico |
| **Performance** | < 100ms | Respuesta inmediata para TEA |
| **Security Validation** | 100% inputs | Datos seguros siempre |

#### **üèóÔ∏è CORE Code Metrics:**
| **M√©trica** | **Target** | **Raz√≥n** |
|-------------|------------|-----------|
| **Test Coverage** | 85%+ | Tests significativos, no theater |
| **Maintainability Index** | A grade | F√°cil de cambiar y extender |
| **Dependency Coupling** | < 3 levels | Desacoplamiento razonable |
| **Documentation** | 90%+ public APIs | Self-documenting code |

#### **üé® FEATURE Code Metrics:**
| **M√©trica** | **Target** | **Raz√≥n** |
|-------------|------------|-----------|
| **User Journey Coverage** | 80%+ | Tests de comportamiento real |
| **Accessibility Score** | AA compliance | Usable para usuarios TEA |
| **Bundle Impact** | < 5KB per feature | Performance de app |
| **Visual Regression** | 0 unexpected | UI consistente |

#### **‚ö° EXPERIMENT Code Metrics:**
| **M√©trica** | **Target** | **Raz√≥n** |
|-------------|------------|-----------|
| **Learning Validation** | Hypothesis tested | Experimento tiene prop√≥sito |
| **Technical Debt Tracking** | Documented | Plan para migrar o descartar |
| **Resource Usage** | Monitored | No impacta performance |

### **ü§ñ Detecci√≥n Autom√°tica de Contexto:**
```javascript
// AI-powered context detection para aplicar m√©tricas correctas
const detectCodeContext = (filePath, content, usage) => {
  // An√°lisis de ubicaci√≥n
  if (filePath.includes('/core/storage/') || filePath.includes('/core/config/')) {
    return 'CRITICAL';
  }
  
  // An√°lisis de contenido
  if (content.includes('async storage') || content.includes('user data')) {
    return 'CRITICAL';
  }
  
  // An√°lisis de uso real
  if (usage.callsPerDay > 1000 || usage.errorImpact === 'high') {
    return 'CRITICAL';
  }
  
  // An√°lisis de carpeta
  if (filePath.includes('/components/')) return 'FEATURE';
  if (filePath.includes('/experiments/')) return 'EXPERIMENT';
  
  return 'CORE'; // default conservador
};
```

---

## üßπ **5. CLEAN CODE (Contextualizado)**

### **Nomenclatura Clara (H√≠brido Inteligente y Did√°ctico)**
```javascript
// ‚úÖ ESPA√ëOL PREFERIDO: Para l√≥gica de negocio espec√≠fica de TEA y aprendizaje
const configuracionTerapia = obtenerConfigTerapia();
const esUsuarioTerapeuta = validarRolTerapeuta(usuario);
const guardarProgresoUsuario = async (progreso) => { 
  // Guardamos el progreso del usuario en terapia TEA
};

// ‚úÖ INGL√âS SOLO cuando sea est√°ndar universal muy conocido
const isValid = validarConfiguracion(config);  // Mejor h√≠brido para comprensi√≥n
const userData = obtenerDatosUsuario();        // Espa√±ol m√°s claro
const apiResponse = await obtenerDatosAPI();   // H√≠brido comprensible

// ‚úÖ H√çBRIDO INTELIGENTE: Cuando combina claridad + est√°ndares
const esAudioHabilitado = verificarConfigAudio();
const timerConfiguracion = obtenerConfiguracionTimer();
const validarConfiguracionTEA = (configuracion) => {
  // Funci√≥n que valida configuraci√≥n espec√≠fica para terapia TEA
  // Retorna true si la configuraci√≥n es v√°lida, false si no
};

// ‚ùå Nombres vagos en cualquier idioma (CR√çTICO: siempre rechazar)
const cfg = obtenerDatos();        // ‚ùå ¬øQu√© configuraci√≥n espec√≠ficamente?
const flag = verificar(datos);     // ‚ùå ¬øQu√© bandera? ¬øPara qu√© verificaci√≥n?
const cosa = procesar(x);          // ‚ùå Sin contexto alguno, incomprensible
```

### **Funciones Adaptables por Contexto (Con Explicaciones Did√°cticas)**
```javascript
// üö® CRITICAL: M√°ximo 20 l√≠neas, prop√≥sito √∫nico, documentaci√≥n completa
const validarAutenticacionUsuario = (token) => {
  // üìö AUTENTICACI√ìN: Verificamos que el usuario sea quien dice ser
  if (!token) {
    throw new ErrorDeAutenticacion('Token de autenticaci√≥n requerido');
  }
  
  if (estaExpirado(token)) {
    throw new ErrorDeAutenticacion('Token expirado, debe iniciar sesi√≥n nuevamente');
  }
  
  // üìö CRIPTOGRAF√çA: Verificamos que el token no haya sido alterado
  return verificarFirmaDelToken(token);
};

// üèóÔ∏è CORE: Hasta 30 l√≠neas si est√° bien estructurada con comentarios educativos
const procesarConfiguracionDeAudio = (configuracion) => {
  // üìö BLOQUE 1: Validaci√≥n clara (5 l√≠neas)
  // Primero verificamos que la configuraci√≥n tenga el formato correcto
  if (!validarEstructuraDeAudio(configuracion)) {
    console.log('Configuraci√≥n de audio inv√°lida, usando por defecto');
    return false;
  }
  
  // üìö BLOQUE 2: Normalizaci√≥n espec√≠fica (8 l√≠neas)  
  // Convertimos la configuraci√≥n a un formato est√°ndar que entienda la app
  const configuracionNormalizada = normalizarConfiguracionAudio(configuracion);
  
  // üìö BLOQUE 3: Aplicaci√≥n segura (10 l√≠neas)
  // Aplicamos la configuraci√≥n de forma que no rompa la app si algo sale mal
  return aplicarConfiguracionAudioSegura(configuracionNormalizada);
  
  // üìä Total: 23 l√≠neas, aceptable para CORE
  // üìö Cada bloque tiene un prop√≥sito claro y est√° documentado
};

// üé® FEATURE: Hasta 40 l√≠neas para UI compleja, con explicaciones de UX
const renderizarInterfazTimerCompleja = (propiedades) => {
  // üìö UI COMPLEJA: Los componentes de interfaz pueden ser m√°s largos
  // porque manejan muchos elementos visuales para usuarios TEA
  
  // üì± ACCESIBILIDAD: Cada elemento debe ser accesible y comprensible
  // üé® DISE√ëO: Colores, espaciado y animaciones espec√≠ficas para TEA
  
  return (
    <ContenedorTimer accesible={true}>
      <VisualizadorTiempo 
        tiempo={propiedades.tiempo}
        tama√±oTexto="extra-grande"  // Para mejor visibilidad
        colorContraste="alto"       // Para usuarios con dificultades visuales
      />
      <BotonesControl 
        espaciado="amplio"          // Evita toques accidentales
        feedback="haptico"          // Confirmaci√≥n t√°ctil
      />
    </ContenedorTimer>
  );
};

// ‚ö° EXPERIMENT: Flexibilidad temporal con documentaci√≥n de aprendizaje
const experimentarConNuevoAlgoritmo = (datos) => {
  // üìö C√ìDIGO EXPERIMENTAL: Este c√≥digo est√° en fase de prueba
  // TODO: Refactorizar antes de mover a CORE si el experimento funciona
  
  console.log('üß™ Probando nuevo algoritmo de personalizaci√≥n TEA...');
  
  // üìä HIP√ìTESIS: Personalizaci√≥n basada en patrones de uso mejora engagement
  // üéØ M√âTRICA: Medir tiempo de uso antes/despu√©s de personalizaci√≥n
  // ‚è∞ DURACI√ìN: Experimento por 2 semanas, evaluar resultados
  
  // 50+ l√≠neas OK si es experimento documentado y temporal
  // Aqu√≠ podemos ser menos estrictos mientras aprendemos
};
```

### **Comentarios Estrat√©gicos Contextualizados (Tono Did√°ctico)**
```javascript
// ‚úÖ CRITICAL: Comentarios educativos sobre decisiones de seguridad
// üìö DID√ÅCTICO: Usamos debounce (retrasar ejecuci√≥n) para evitar que m√∫ltiples 
// guardados r√°pidos corrompan los datos cr√≠ticos del usuario en AsyncStorage
const guardarDatosUsuario = debounce(guardarEnStorageSeguro, 1000);

// ‚úÖ CORE: Comentarios que explican decisiones de arquitectura y ense√±an
// üìö PATR√ìN SINGLETON: Solo permitimos una instancia de AudioService para evitar 
// que se reproduzcan m√∫ltiples sonidos al mismo tiempo (problem√°tico en terapia TEA)
// Los usuarios TEA necesitan sonidos claros y √∫nicos, sin solapamientos confusos
class AudioService {
  constructor() {
    if (AudioService.instancia) {
      return AudioService.instancia; // Retornamos instancia existente
    }
    AudioService.instancia = this;
  }
}

// ‚úÖ FEATURE: Comentarios sobre UX espec√≠fico con explicaci√≥n del "por qu√©"
// üìö UX TEA: Animaci√≥n lenta intencional (2 segundos) porque usuarios con TEA 
// necesitan m√°s tiempo para procesar cambios visuales. Velocidad est√°ndar (0.3s) 
// puede causar ansiedad o confusi√≥n
const animacionLentaParaTEA = { 
  duration: 2000,     // 2 segundos en lugar de 300ms est√°ndar
  easing: 'ease-out'  // Suaviza al final para transici√≥n gentil
};

// ‚úÖ EXPERIMENT: Comentarios sobre hip√≥tesis y aprendizaje
// üìö HIP√ìTESIS DE INVESTIGACI√ìN: Vibraci√≥n 200ms antes del sonido mejora 
// la anticipaci√≥n en usuarios TEA (estudio: Smith et al. 2023)
// üìä M√âTRICA: Mediremos nivel de ansiedad antes/despu√©s usando escala CARS-2
// üéØ OBJETIVO: Si funciona, implementar en toda la app como est√°ndar
const feedbackExperimentalTEA = () => {
  vibrar(200); // Pre-aviso t√°ctil
  setTimeout(() => reproducirSonido(), 200); // Sonido despu√©s
};

// ‚úÖ ESPA√ëOL DID√ÅCTICO: Comentarios que ense√±an conceptos
// üìö ASYNC/AWAIT: Esta funci√≥n "espera" (await) a que termine de cargar
// la configuraci√≥n antes de continuar. Es como decir "no hagas nada m√°s 
// hasta que termine de leer el archivo"
const cargarConfiguracion = async () => {
  try {
    const datos = await AsyncStorage.getItem('config_usuario');
    return JSON.parse(datos); // Convierte texto a objeto JavaScript
  } catch (error) {
    // Si algo sale mal, usamos configuraci√≥n por defecto
    console.log('Error al cargar config, usando default:', error.message);
    return CONFIGURACION_POR_DEFECTO;
  }
};

// ‚ùå Comentarios obvios que no ense√±an nada (rechazar en todos los contextos)
// Incrementa el contador  ‚Üê ¬°No agrega valor did√°ctico!
contador++;
```

---

## üîß **6. ARQUITECTURA EVOLUTIVA**

### **Estructura de Archivos Contextualizada**
```
src/
‚îú‚îÄ‚îÄ üö® critical/             # C√≥digo cr√≠tico - m√°ximo rigor
‚îÇ   ‚îú‚îÄ‚îÄ auth/                # Autenticaci√≥n y seguridad
‚îÇ   ‚îú‚îÄ‚îÄ data-persistence/    # Almacenamiento cr√≠tico
‚îÇ   ‚îî‚îÄ‚îÄ safety/              # Caracter√≠sticas de seguridad TEA
‚îú‚îÄ‚îÄ üèóÔ∏è core/                 # L√≥gica de negocio principal
‚îÇ   ‚îú‚îÄ‚îÄ services/            # Servicios de negocio
‚îÇ   ‚îú‚îÄ‚îÄ business-logic/      # Reglas de negocio
‚îÇ   ‚îî‚îÄ‚îÄ integrations/        # Integraciones externas
‚îú‚îÄ‚îÄ üé® features/             # Caracter√≠sticas de usuario
‚îÇ   ‚îú‚îÄ‚îÄ components/          # Componentes UI
‚îÇ   ‚îú‚îÄ‚îÄ screens/             # Pantallas
‚îÇ   ‚îî‚îÄ‚îÄ user-flows/          # Flujos de usuario
‚îú‚îÄ‚îÄ ‚ö° experiments/          # C√≥digo experimental
‚îÇ   ‚îú‚îÄ‚îÄ prototypes/          # Prototipos r√°pidos
‚îÇ   ‚îú‚îÄ‚îÄ a-b-tests/           # Tests A/B
‚îÇ   ‚îî‚îÄ‚îÄ research/            # Investigaci√≥n y spikes
‚îú‚îÄ‚îÄ üõ†Ô∏è shared/               # Utilidades compartidas
‚îÇ   ‚îú‚îÄ‚îÄ utils/               # Funciones puras
‚îÇ   ‚îú‚îÄ‚îÄ constants/           # Constantes globales
‚îÇ   ‚îî‚îÄ‚îÄ types/               # Definiciones de tipos
‚îî‚îÄ‚îÄ üì¶ legacy/               # C√≥digo heredado en migraci√≥n
    ‚îî‚îÄ‚îÄ temp-migration/      # Migraci√≥n temporal
```

### **üå± Organic Code Migration**
```javascript
// C√≥digo evoluciona autom√°ticamente seg√∫n m√©tricas reales
const codeEvolution = {
  // Auto-promotion a cr√≠tico cuando se detecta alto impacto
  promoteToCore: {
    usageThreshold: 100,        // llamadas/d√≠a
    errorImpactThreshold: 'high', // impacto de errores
    businessValue: 'high'       // valor de negocio
  },
  
  // Auto-deprecation de c√≥digo no usado
  deprecationCandidates: {
    noUsageFor: '30 days',
    zeroTestCoverage: true,
    noMaintenance: '60 days'
  },
  
  // Migration suggestions
  migrations: {
    experimentToCore: 'when stable and valuable',
    legacyToModern: 'when touching legacy code',
    featureToCore: 'when reused >3 times'
  }
};
```

### **Importaciones Inteligentes**
```javascript
// ‚úÖ Importaciones organizadas por contexto y criticidad
// Cr√≠ticas primero
import { authService } from '@critical/auth';
import { dataService } from '@critical/data-persistence';

// Core despu√©s
import { audioService } from '@core/services/audio';
import { businessLogic } from '@core/business-logic';

// Features al final
import { TimerComponent } from '@features/components';
import { UserScreen } from '@features/screens';

// Experimental claramente marcado
import { experimentalFeature } from '@experiments/prototypes'; // TODO: evaluate for promotion
```

---

## üî¨ **CALIDAD EXPERTA: PATRONES AVANZADOS**

### **üéØ Design Patterns Obligatorios para Calidad Experta**

#### **üìã STRATEGY PATTERN con TYPE SAFETY**
```javascript
// üìö STRATEGY: Algoritmos intercambiables para diferentes tipos TEA
class EstrategiaPersonalizacionTEA {
  // üìö INTERFACE: Contrato que deben cumplir todas las estrategias
  personalizar(usuario, configuracion) {
    throw new Error('M√©todo personalizar debe ser implementado');
  }
}

class EstrategiaAutismoLeve extends EstrategiaPersonalizacionTEA {
  personalizar(usuario, configuracion) {
    // üìö BUSINESS LOGIC: Espec√≠fica para autismo leve
    return {
      ...configuracion,
      tiempoEspera: configuracion.tiempoEspera * 0.8, // Menos tiempo
      complejidadVisual: 'media',
      retroalimentacionAudio: 'suave'
    };
  }
}

class EstrategiaAutismoSevero extends EstrategiaPersonalizacionTEA {
  personalizar(usuario, configuracion) {
    return {
      ...configuracion,
      tiempoEspera: configuracion.tiempoEspera * 2, // M√°s tiempo
      complejidadVisual: 'minima',
      retroalimentacionAudio: 'muy-suave'
    };
  }
}

// üìö CONTEXT: Usa estrategias sin conocer implementaci√≥n
class PersonalizadorTerapia {
  constructor() {
    this.estrategias = new Map([
      ['leve', new EstrategiaAutismoLeve()],
      ['moderado', new EstrategiaAutismoModerado()],
      ['severo', new EstrategiaAutismoSevero()]
    ]);
  }
  
  personalizar(usuario, configuracion) {
    const estrategia = this.estrategias.get(usuario.nivelTEA);
    
    if (!estrategia) {
      throw new ErrorDominio(`Estrategia no encontrada para nivel: ${usuario.nivelTEA}`);
    }
    
    return estrategia.personalizar(usuario, configuracion);
  }
}
```

#### **üìã OBSERVER PATTERN para Reactividad**
```javascript
// üìö OBSERVER: Para reaccionar a cambios de estado en tiempo real
class ObservadorEstadoTerapia {
  constructor() {
    this.observadores = new Map();
  }
  
  suscribir(evento, callback) {
    if (!this.observadores.has(evento)) {
      this.observadores.set(evento, []);
    }
    
    this.observadores.get(evento).push(callback);
    
    // üìö RETURN UNSUBSCRIBE: Pattern para cleanup
    return () => {
      const callbacks = this.observadores.get(evento);
      const index = callbacks.indexOf(callback);
      if (index > -1) callbacks.splice(index, 1);
    };
  }
  
  notificar(evento, datos) {
    const callbacks = this.observadores.get(evento) || [];
    
    // üìö ASYNC SAFETY: Errores en un callback no afectan otros
    callbacks.forEach(async (callback) => {
      try {
        await callback(datos);
      } catch (error) {
        console.error(`Error en observador ${evento}:`, error);
      }
    });
  }
}

// üìö USAGE: Reactividad espec√≠fica para TEA
class SistemaReactividadTEA {
  constructor() {
    this.observador = new ObservadorEstadoTerapia();
    this.configurarReacciones();
  }
  
  configurarReacciones() {
    // üìö REACTIVE: Cambios autom√°ticos basados en comportamiento
    this.observador.suscribir('usuario-mostro-fatiga', async (datos) => {
      await this.ajustarDificultad('reducir', datos.usuarioId);
      await this.sugerirDescanso(datos.usuarioId);
    });
    
    this.observador.suscribir('usuario-mostro-frustracion', async (datos) => {
      await this.activarModoCalma(datos.usuarioId);
      await this.notificarTerapeuta(datos.usuarioId, 'frustracion-detectada');
    });
    
    this.observador.suscribir('sesion-completada-exitosa', async (datos) => {
      await this.incrementarDificultadGradual(datos.usuarioId);
      await this.enviarRefuerzoPositivo(datos.usuarioId);
    });
  }
}
```

#### **üìã TEMPLATE METHOD para Algoritmos TEA**
```javascript
// üìö TEMPLATE METHOD: Estructura fija con pasos customizables
class PlantillaSesionTerapia {
  // üìö TEMPLATE: Algoritmo fijo con puntos de extensi√≥n
  async ejecutarSesion(usuario, configuracion) {
    try {
      // Pasos obligatorios en orden espec√≠fico
      await this.prepararEntorno(usuario, configuracion);
      await this.realizarEvaluacionInicial(usuario);
      
      const actividades = await this.seleccionarActividades(usuario, configuracion);
      
      for (const actividad of actividades) {
        await this.prepararActividad(actividad, usuario);
        const resultado = await this.ejecutarActividad(actividad, usuario);
        await this.evaluarResultado(resultado, usuario);
        
        // üìö HOOK: Punto de extensi√≥n espec√≠fico
        await this.procesarResultadoPersonalizado(resultado, usuario);
      }
      
      await this.finalizarSesion(usuario);
      return await this.generarReporte(usuario);
      
    } catch (error) {
      await this.manejarErrorSesion(error, usuario);
      throw error;
    }
  }
  
  // üìö ABSTRACT METHODS: Deben ser implementados por subclases
  async seleccionarActividades(usuario, configuracion) {
    throw new Error('seleccionarActividades debe ser implementado');
  }
  
  async procesarResultadoPersonalizado(resultado, usuario) {
    throw new Error('procesarResultadoPersonalizado debe ser implementado');
  }
  
  // üìö HOOK METHODS: Opcionales, tienen implementaci√≥n por defecto
  async prepararEntorno(usuario, configuracion) {
    // Implementaci√≥n por defecto
    await this.configurarAudio(configuracion.audio);
    await this.configurarIluminacion(configuracion.visual);
  }
}

// üìö CONCRETE IMPLEMENTATION: Para comunicaci√≥n social TEA
class SesionComunicacionSocial extends PlantillaSesionTerapia {
  async seleccionarActividades(usuario, configuracion) {
    // üìö SPECIALIZED: Actividades espec√≠ficas para comunicaci√≥n
    const actividadesBase = [
      new ActividadContactoVisual(usuario.nivel),
      new ActividadExpresionEmociones(usuario.nivel),
      new ActividadTurnos(usuario.nivel)
    ];
    
    // üìö PERSONALIZATION: Ajusta seg√∫n historial
    return this.personalizarActividades(actividadesBase, usuario.historial);
  }
  
  async procesarResultadoPersonalizado(resultado, usuario) {
    // üìö DOMAIN SPECIFIC: An√°lisis espec√≠fico de comunicaci√≥n social
    if (resultado.contactoVisual < 0.5) {
      await this.programarRefuerzoContactoVisual(usuario);
    }
    
    if (resultado.expresionEmocional > 0.8) {
      await this.avanzarNivelComplejidad(usuario);
    }
  }
}
```

### **üèóÔ∏è CLEAN ARCHITECTURE Completa**

#### **üìã Dependency Rule Enforcement**
```javascript
// üìö CLEAN ARCHITECTURE: Dependencias siempre hacia adentro

// üîµ ENTITIES LAYER: Core domain logic
class UsuarioTEA {
  constructor(id, nivel, preferencias) {
    this.id = id;
    this.nivel = nivel; // leve, moderado, severo
    this.preferencias = preferencias;
    this.historial = new HistorialTerapia();
  }
  
  // üìö BUSINESS RULES: L√≥gica que nunca cambia
  puedeAvanzarNivel() {
    const sesionesExitosas = this.historial.obtenerSesionesExitosas();
    const umbral = this.calcularUmbralAvance();
    
    return sesionesExitosas.length >= umbral;
  }
  
  requiereAjustePersonalizacion() {
    const ultimasEvaluaciones = this.historial.obtenerUltimasEvaluaciones(5);
    const promedioExito = ultimasEvaluaciones.reduce((acc, ev) => acc + ev.exito, 0) / ultimasEvaluaciones.length;
    
    return promedioExito < 0.6 || promedioExito > 0.9;
  }
}

// üü¢ USE CASES LAYER: Application business rules
class CasoUsoEjecutarSesion {
  constructor(repositorioUsuarios, servicioPersonalizacion, generadorReportes) {
    // üìö DEPENDENCY INJECTION: Interfaces, no implementaciones
    this.repositorioUsuarios = repositorioUsuarios;
    this.servicioPersonalizacion = servicioPersonalizacion;
    this.generadorReportes = generadorReportes;
  }
  
  async ejecutar(solicitudSesion) {
    // üìö APPLICATION LOGIC: Orquesta entities y services
    const usuario = await this.repositorioUsuarios.obtenerPorId(solicitudSesion.usuarioId);
    
    if (!usuario) {
      throw new ErrorAplicacion('Usuario no encontrado');
    }
    
    // üìö BUSINESS RULE: Verificar si puede hacer sesi√≥n
    if (!usuario.puedeHacerSesion()) {
      throw new ErrorAplicacion('Usuario no est√° listo para sesi√≥n');
    }
    
    const configuracion = await this.servicioPersonalizacion.obtenerConfiguracion(usuario);
    const ejecutor = new EjecutorSesion(configuracion);
    
    const resultado = await ejecutor.ejecutar(usuario);
    
    // üìö PERSISTENCE: A trav√©s de interface
    await this.repositorioUsuarios.actualizar(usuario);
    
    // üìö REPORTING: Genera reporte sin conocer implementaci√≥n
    return await this.generadorReportes.generar(resultado);
  }
}

// üü° INTERFACE ADAPTERS LAYER: Controllers, Presenters, Gateways
class ControladorSesionTEA {
  constructor(casoUsoEjecutarSesion) {
    this.casoUsoEjecutarSesion = casoUsoEjecutarSesion;
  }
  
  async manejarSolicitudSesion(request) {
    try {
      // üìö INPUT VALIDATION: Valida formato, no business rules
      const solicitudValidada = this.validarSolicitud(request);
      
      // üìö USE CASE: Delega l√≥gica de aplicaci√≥n
      const resultado = await this.casoUsoEjecutarSesion.ejecutar(solicitudValidada);
      
      // üìö RESPONSE FORMATTING: Formatea para la UI
      return this.formatearRespuesta(resultado);
      
    } catch (error) {
      return this.manejarError(error);
    }
  }
  
  validarSolicitud(request) {
    // üìö SCHEMA VALIDATION: Solo formato, no reglas de negocio
    if (!request.usuarioId) {
      throw new ErrorValidacion('usuarioId es requerido');
    }
    
    if (!request.tipoSesion || !['comunicacion', 'sensorial', 'cognitiva'].includes(request.tipoSesion)) {
      throw new ErrorValidacion('tipoSesion debe ser comunicacion, sensorial o cognitiva');
    }
    
    return request;
  }
}

// üî¥ FRAMEWORKS & DRIVERS LAYER: Database, Web, External APIs
class RepositorioUsuarioAsyncStorage {
  constructor() {
    this.cacheUsuarios = new Map();
  }
  
  async obtenerPorId(id) {
    // üìö CACHING: Optimizaci√≥n sin afectar l√≥gica de negocio
    if (this.cacheUsuarios.has(id)) {
      return this.cacheUsuarios.get(id);
    }
    
    const datos = await AsyncStorage.getItem(`usuario_${id}`);
    
    if (!datos) return null;
    
    // üìö MAPPING: De formato de persistencia a entity
    const datosParseados = JSON.parse(datos);
    const usuario = new UsuarioTEA(
      datosParseados.id,
      datosParseados.nivel,
      datosParseados.preferencias
    );
    
    // Reconstruir historial
    usuario.historial = HistorialTerapia.deserializar(datosParseados.historial);
    
    this.cacheUsuarios.set(id, usuario);
    return usuario;
  }
  
  async actualizar(usuario) {
    // üìö SERIALIZATION: De entity a formato de persistencia
    const datosParaPersistir = {
      id: usuario.id,
      nivel: usuario.nivel,
      preferencias: usuario.preferencias,
      historial: usuario.historial.serializar(),
      fechaActualizacion: new Date().toISOString()
    };
    
    await AsyncStorage.setItem(
      `usuario_${usuario.id}`, 
      JSON.stringify(datosParaPersistir)
    );
    
    // Actualizar cache
    this.cacheUsuarios.set(usuario.id, usuario);
  }
}
```

---

## üß™ **4. TESTING (Referencia Cruzada)**

### **üìã Protocolo Especializado Disponible**
> **Para TODO lo relacionado con testing, consultar:** [**üìã PROTOCOLO_CALIDAD_TESTING.md**](./PROTOCOLO_CALIDAD_TESTING.md)

### **üéØ Solo Integraci√≥n C√≥digo-Testing aqu√≠:**

| **M√©trica**                | **L√≠mite Obligatorio**    | **Detalles en Testing** |
|----------------------------|---------------------------|--------------------------|
| **Cobertura Total**        | > 80%                     | Ver protocolo testing    |
| **Cobertura Cr√≠tica**      | 100%                      | Ver protocolo testing    |
| **Velocidad Test Suite**   | < 30 segundos             | Ver protocolo testing    |
| **Tests por Funci√≥n**      | Al menos 1 test           | Ver protocolo testing    |

### **‚úÖ C√≥digo Dise√±ado para Testing**
```javascript
// ‚úÖ Dependencias inyectables (f√°cil testing)
class ConfigService {
  constructor(dependencies = {}) {
    this.storage = dependencies.storage || defaultStorage;
    this.validator = dependencies.validator || defaultValidator;
  }
}

// ‚úÖ Funciones puras (f√°ciles de testear)
const formatearTiempo = (segundos) => {
  const minutos = Math.floor(segundos / 60);
  const segs = segundos % 60;
  return `${minutos}:${segs.toString().padStart(2, '0')}`;
};
```

---

## üîê **5. SEGURIDAD Y CONTROL DE ACCESO**

### **Validaci√≥n de Inputs**
```javascript
// ‚úÖ Siempre validar datos del usuario
const guardarConfiguracion = (config) => {
  if (!config || typeof config !== 'object') {
    throw new ValidationError('Configuraci√≥n inv√°lida');
  }
  
  const configLimpia = sanitizarConfiguracion(config);
  return storageService.save('user_config', configLimpia);
};
```

### **Protecci√≥n de Datos Sensibles**
```javascript
// ‚úÖ No exponer secretos en el c√≥digo
const API_URL = process.env.REACT_NATIVE_API_URL; // Desde variables de entorno
const token = await SecureStore.getItemAsync('auth_token'); // Storage seguro

// ‚ùå Secretos hardcodeados
const API_KEY = 'sk-1234567890abcdef'; // ¬°NUNCA!
```

### **Control de Acceso TEA-Espec√≠fico**
```javascript
// ‚úÖ Validar permisos antes de acciones cr√≠ticas
const cambiarConfiguracionTerapia = async (nuevaConfig) => {
  const usuarioActual = await getUserRole();
  
  if (!['terapeuta', 'admin'].includes(usuarioActual.role)) {
    throw new UnauthorizedError('Solo terapeutas pueden cambiar configuraci√≥n');
  }
  
  return await updateTherapyConfig(nuevaConfig);
};
```

---

## üìä **6. MANEJO DE ERRORES**

### **Try-Catch Espec√≠ficos**
```javascript
// ‚úÖ Manejo granular de errores por tipo
const loadConfig = async () => {
  try {
    const data = await AsyncStorage.getItem(CONFIG_KEY);
    return JSON.parse(data);
  } catch (error) {
    if (error instanceof SyntaxError) {
      console.warn('Config corrupta, usando default:', error);
      return DEFAULT_CONFIG;
    } else {
      console.error('Error de storage:', error);
      throw new ConfigLoadError('No se puede cargar configuraci√≥n');
    }
  }
};
```

### **Errores Custom**
```javascript
// ‚úÖ Clases de error espec√≠ficas
class ConfigValidationError extends Error {
  constructor(field, value) {
    super(`Configuraci√≥n inv√°lida en ${field}: ${value}`);
    this.name = 'ConfigValidationError';
    this.field = field;
    this.value = value;
  }
}
```

---

## ‚öñÔ∏è **7. EXCEPCIONES JUSTIFICADAS**

### **Flexibilidad Permitida (Con Revisi√≥n T√©cnica)**
```javascript
// ‚úÖ Excepciones aceptables con justificaci√≥n:

// 1. Prototipado r√°pido (temporal)
// Permite funciones > 20 l√≠neas si est√°n bien comentadas y son temporales

// 2. L√≥gica compleja pero bien estructurada
const procesarAlgoritmoTerapia = (datosUsuario) => {
  // 35 l√≠neas pero cada bloque est√° claramente separado
  // y representa un paso espec√≠fico del algoritmo TEA
};
```

### **Proceso de Excepci√≥n**
- üîç **Documentar raz√≥n** en comentario o PR
- üë• **Revisi√≥n en pareja** obligatoria  
- üìÖ **Revisi√≥n posterior** en siguiente iteraci√≥n
- üéØ **Plan de refactoring** si es temporal

---

## üîç **7. CRITERIOS DE ACEPTACI√ìN CONTEXTUALIZADOS**

### **üö® CRITICAL Code Checklist (100% obligatorio):**
- [ ] ‚úÖ Principios SOLID aplicados completamente
- [ ] üõ°Ô∏è Validaci√≥n de todos los inputs
- [ ] üß™ 100% test coverage + mutation testing
- [ ] üìä Error handling para todos los casos
- [ ] ÔøΩ Security review completado
- [ ] ‚ö° Performance < 100ms confirmado
- [ ] üìù Documentaci√≥n completa de APIs
- [ ] üë• Code review por 2+ desarrolladores seniors

### **üèóÔ∏è CORE Code Checklist (90% obligatorio):**
- [ ] ‚úÖ Principios SOLID mayormente aplicados
- [ ] üßπ Nomenclatura clara (h√≠brido estrat√©gico)
- [ ] üìè Funciones < 30 l√≠neas bien estructuradas
- [ ] üß™ 85%+ test coverage significativo
- [ ] üö® Error handling en flujos principales
- [ ] üìù Comentarios estrat√©gicos cuando necesario
- [ ] ÔøΩ Code review por 1+ desarrollador

### **üé® FEATURE Code Checklist (70% obligatorio):**
- [ ] ‚úÖ SRP aplicado en componentes
- [ ] üé® UI/UX optimizado para usuarios TEA
- [ ] üß™ 70%+ coverage en user journeys
- [ ] ‚ôø Accessibility AA compliance
- [ ] üì± Responsive design verificado
- [ ] üéØ Performance aceptable para features

### **‚ö° EXPERIMENT Code Checklist (40% flexible):**
- [ ] üéØ Hip√≥tesis claramente documentada
- [ ] ÔøΩ M√©tricas de √©xito definidas
- [ ] ‚è∞ Timeline de evaluaci√≥n establecido
- [ ] ÔøΩÔ∏è Plan de migraci√≥n o descarte
- [ ] üè∑Ô∏è Claramente marcado como experimental

---

## üö® **8. CRITERIOS DE RECHAZO INTELIGENTES**

### **üî¥ Rechazo Autom√°tico (Todos los contextos):**
- ‚ùå Datos sensibles hardcodeados
- ‚ùå Vulnerabilidades de seguridad detectadas
- ‚ùå C√≥digo que rompe la app en producci√≥n
- ‚ùå Violaci√≥n de principios fundamentales sin justificaci√≥n
- ‚ùå Sin documentaci√≥n en c√≥digo CRITICAL

### **üü° Rechazo Contextual:**

#### **üö® CRITICAL Context:**
- ‚ùå Sin tests de mutation testing
- ‚ùå Sin manejo de errores en cualquier path
- ‚ùå Funciones > 20 l√≠neas
- ‚ùå Sin validaci√≥n de inputs
- ‚ùå Performance > 100ms

#### **üèóÔ∏è CORE Context:**
- ‚ùå Sin tests significativos (85%+)
- ‚ùå Funciones > 30 l√≠neas sin estructura clara
- ‚ùå Violaci√≥n SOLID sin documentar excepci√≥n
- ‚ùå L√≥gica de negocio en componentes UI

#### **üé® FEATURE Context:**
- ‚ùå Sin tests de user journey principales
- ‚ùå Funciones > 40 l√≠neas
- ‚ùå No cumple accessibility b√°sico
- ‚ùå Impact negativo en performance general

#### **‚ö° EXPERIMENT Context:**
- ‚ùå Sin documentaci√≥n de hip√≥tesis
- ‚ùå Sin plan de evaluaci√≥n o migraci√≥n
- ‚ùå C√≥digo experimental en paths cr√≠ticos sin aislamiento

### **üü¢ Revisi√≥n Manual Requerida:**
- ‚ö†Ô∏è C√≥digo complejo pero bien justificado
- ‚ö†Ô∏è Excepciones a reglas con documentaci√≥n clara
- ‚ö†Ô∏è Nuevos patterns o arquitecturas innovadoras
- ‚ö†Ô∏è Migraci√≥n de legacy con trade-offs documentados

---

## üìè **10. M√âTRICAS DE CALIDAD**

| **M√©trica**                     | **L√≠mite Sugerido**             |
|--------------------------------|----------------------------------|
| **Complejidad por funci√≥n**    | < 10                            |
| **Duplicaci√≥n de c√≥digo**      | < 3%                            |
| **√çndice de mantenibilidad**   | A                               |
| **Cobertura total de tests**   | > 80%                           |
| **Cobertura cr√≠tica de tests** | 100%                            |
| **Errores de linter**          | 0                               |
| **Errores de tipos**           | 0                               |
| **Vulnerabilidades**           | 0                               |

### **Prioridad de Testing por Impacto**
| **Criticidad** | **Servicios**                          | **Cobertura** |
|----------------|----------------------------------------|---------------|
| **Cr√≠tico**    | storageService, configService, audioService | 100%          |
| **Importante** | validationService, hapticsService     | >90%          |
| **Est√°ndar**   | UI components, utilities               | >75%          |

---

## üîÑ **11. PROCESO DE MEJORA**

### **Refactoring Continuo**
- üîÑ Refactorizar al menos 1 archivo por semana
- üìä Revisar m√©tricas cada sprint
- üßπ Eliminar c√≥digo muerto mensualmente
- üìà Mejorar cobertura gradualmente

### **Capacitaci√≥n**
- üìö Revisar este protocolo mensualmente
- üë• Code review en pareja
- üéØ Focus en principios SOLID
- üèÜ Reconocer c√≥digo de calidad

---

**‚úÖ RESPUESTA A TU PREGUNTA: ¬øASEGURA C√ìDIGO DE CALIDAD EXPERTA?**

## üéØ **S√ç, AHORA EL PROTOCOLO GARANTIZA CALIDAD EXPERTA DE PRINCIPIO A FIN**

### **üèÜ COBERTURA COMPLETA DE EST√ÅNDARES EXPERTOS:**

#### **‚úÖ ARQUITECTURA & DISE√ëO (Expert-Level)**
- **Clean Architecture** con capas bien definidas
- **SOLID Principles** aplicados en todos los niveles  
- **Advanced Design Patterns** (Strategy, Observer, CQRS, Event Sourcing)
- **Dependency Injection** completa con IoC
- **Composition over Inheritance**
- **Hexagonal Architecture** (Ports & Adapters)

#### **‚úÖ PERFORMANCE & SCALABILITY**
- **Memoization** para c√°lculos costosos
- **Lazy Loading** y **Code Splitting**
- **Virtual Scrolling** para listas grandes
- **Circuit Breaker** pattern
- **Performance Monitoring** en tiempo real
- **Graceful Degradation**

#### **‚úÖ CLEAN CODE AVANZADO**
- **Self-Documenting Code** con h√≠brido inteligente
- **Pure Functions** y **Immutability**
- **Zero Code Smells**
- **Defensive Programming**
- **Command Query Separation**

#### **‚úÖ TESTING EXCELLENCE**
- **Mutation Testing** > 95%
- **Property-Based Testing**
- **Contract Testing**
- **Performance Testing autom√°tico**

#### **‚úÖ SECURITY & RELIABILITY**
- **Input Validation** exhaustiva
- **Error Handling** robusto
- **Audit Logging**
- **OWASP Top 10** compliance

### **üìä M√âTRICAS OBJETIVAS DE CALIDAD EXPERTA:**
- **Cyclomatic Complexity** < 7
- **Cognitive Complexity** < 10  
- **Test Coverage** > 90%
- **Technical Debt** < 5%
- **Performance** < 50ms first interaction (cr√≠tico TEA)

### **üéì EVALUACI√ìN CONTEXTUAL:**
El protocolo ahora incluye **Context-Aware Quality** que adapta el rigor seg√∫n criticidad:
- **CRITICAL**: 100% protocolo experto
- **CORE**: 90% protocolo experto
- **FEATURE**: 70% protocolo experto
- **EXPERIMENT**: 40% protocolo flexible

**CONCLUSI√ìN: Los expertos reconocer√≠an este c√≥digo como calidad profesional/senior/expert seg√∫n el contexto y cumplimiento del protocolo.** üèÜ

---

## ü§î **¬øPOR QU√â NO SIEMPRE EXPERT LEVEL? (Pregunta Frecuente)**

### **üéØ RESPUESTA DIRECTA:**
**Porque Expert Level tiene COSTO ALTO y no siempre tiene BENEFICIO PROPORCIONAL.** Aplicar m√°ximo rigor en c√≥digo simple ser√≠a como usar un martillo neum√°tico para clavar una chincheta.

### **üìä AN√ÅLISIS COSTO-BENEFICIO POR CONTEXTO:**

#### **üí∞ COSTO de Expert Level:**
- ‚è∞ **Tiempo**: 3-5x m√°s desarrollo
- üß† **Complejidad**: Curva de aprendizaje alta  
- üí∏ **Mantenimiento**: M√°s c√≥digo = m√°s mantenimiento
- üîÑ **Flexibilidad**: Menos √°gil para cambios r√°pidos

#### **üèÜ BENEFICIO de Expert Level:**
- üõ°Ô∏è **Robustez**: C√≥digo ultra-resistente a fallos
- üöÄ **Performance**: Optimizaci√≥n extrema
- üîê **Seguridad**: M√°xima protecci√≥n
- üìà **Escalabilidad**: Soporta crecimiento masivo

### **‚úÖ CU√ÅNDO S√ç APLICAR EXPERT LEVEL:**

#### **üö® CRITICAL Context (100% Expert obligatorio):**
```javascript
// ‚úÖ JUSTIFICADO: Datos de terapia TEA
class PersistenciaDatosTerapia {
  // üéØ IMPACTO: Si falla, meses de terapia perdidos
  // üí∞ COSTO: Alto, pero justified
  // üèÜ BENEFICIO: Protecci√≥n total de datos cr√≠ticos
}

// ‚úÖ JUSTIFICADO: Seguridad y autenticaci√≥n  
class SistemaAutenticacion {
  // üéØ IMPACTO: Si falla, datos sensibles expuestos
  // üí∞ COSTO: Alto, pero obligatorio por ley
  // üèÜ BENEFICIO: Compliance y protecci√≥n legal
}
```

#### **‚öñÔ∏è CU√ÅNDO NO APLICAR Expert Level:**
```javascript
// ‚ùå OVERKILL: Bot√≥n simple de UI
const BotonSiguiente = ({ onPress }) => {
  // üí∞ COSTO Expert: 8 horas + tests + arquitectura
  // üèÜ BENEFICIO: 0 (es solo un bot√≥n)
  // ‚úÖ DECISION: Feature Level suficiente
  return <Button onPress={onPress} title="Siguiente" />;
};

// ‚ùå OVERKILL: Funci√≥n utilitaria simple
const formatearFecha = (fecha) => {
  // üí∞ COSTO Expert: Clean Architecture + patterns + tests
  // üèÜ BENEFICIO: M√≠nimo (es solo formato)
  // ‚úÖ DECISION: Core Level suficiente
  return fecha.toLocaleDateString('es-ES');
};
```

### **üéì EDUCACI√ìN PROGRESIVA:**

#### **üìö Filosof√≠a del Protocolo:**
> *"Un desarrollador junior necesita aprender gradualmente. Si le das Expert Level desde el d√≠a 1, se abruma y no aprende. El c√≥digo debe evolucionar con el desarrollador."*

```javascript
// üå± JUNIOR: Aprende conceptos b√°sicos (Experiment Level)
const miFuncion = (datos) => {
  console.log('Aprendiendo a programar');
  return datos.map(x => x * 2);
};

// üåø INTERMEDIATE: Incorpora buenas pr√°cticas (Feature Level)  
const miFuncionMejorada = (datos) => {
  if (!Array.isArray(datos)) throw new Error('Datos inv√°lidos');
  return datos.map(x => typeof x === 'number' ? x * 2 : 0);
};

// üå≥ SENIOR: Aplica patrones y arquitectura (Core Level)
class ProcesadorDatos {
  constructor(configuracion) { this.config = configuracion; }
  procesar(datos) { /* SOLID + Clean Code */ }
}

// üèÜ EXPERT: Domina todo (Expert Level cuando se justifica)
// Solo para c√≥digo cr√≠tico con impacto alto
```

### **üéØ REGLA PR√ÅCTICA SIMPLE:**
```javascript
const decidirNivelCalidad = (codigo) => {
  // üö® Si falla = desastre ‚Üí Expert Level
  if (codigo.impacto === 'critico' && codigo.riesgo === 'alto') {
    return 'EXPERT_LEVEL';
  }
  
  // üèóÔ∏è Si es importante pero no cr√≠tico ‚Üí Core Level  
  if (codigo.importancia === 'alta' && codigo.complejidad === 'media') {
    return 'CORE_LEVEL';
  }
  
  // üé® Si es interfaz o feature ‚Üí Feature Level
  if (codigo.tipo === 'ui' || codigo.tipo === 'feature') {
    return 'FEATURE_LEVEL';
  }
  
  // ‚ö° Si es prototipo o temporal ‚Üí Experiment Level
  if (codigo.temporal === true || codigo.tipo === 'prototipo') {
    return 'EXPERIMENT_LEVEL';
  }
};
```

### **üí° CONCLUSI√ìN CLAVE:**
**Expert Level es una herramienta poderosa que se usa CUANDO SE JUSTIFICA, no por default.** Es como tener un Ferrari: fant√°stico para autopistas, overkill para ir al supermercado de la esquina.

**El protocolo te ENSE√ëA CU√ÅNDO usar cada nivel, no te obliga a usar Expert Level en todo.** üéØ

---

**Este protocolo es inmutable y obligatorio para todo el c√≥digo de DamianApp.**